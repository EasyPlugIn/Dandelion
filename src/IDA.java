import java.util.ArrayList;

import org.json.JSONArray;

import processing.core.PApplet;
@SuppressWarnings("serial")
public class IDA extends PApplet {
    /* Class declarations */
    static abstract class Command {
        public Command(String name) {
            this.name = name;
        }
        public String name;
        abstract public void run(JSONArray args);
    }
    static abstract class DF {
        public DF (String name) {
            this.name = name;
        }
        public String name;
        public boolean selected;
    };
    static abstract class ODF extends DF {
        public ODF (String name) {
            super(name);
        }
        abstract public void write(JSONArray data);
    }
    static abstract class IDF extends DF {
        public IDF (String name) {
            super(name);
        }
    }
    /* Declaration of command list and DF list */
    static ArrayList<Command> cmd_list = new ArrayList<Command>();
    static ArrayList<DF> df_list = new ArrayList<DF>();
    public static boolean suspended = true;
    static InternalIDAapi internal_ida_api = new InternalIDAapi();
    /* Declaration of helper functions */
    static void add_command (Command... ncmds) {
        for (Command ncmd: ncmds) {
            cmd_list.add(ncmd);
        }
    }
    static void add_df (DF... dfs) {
        for (DF df: dfs) {
            df_list.add(df);
        }
    }
    /* Declaration of write() function */
    public static void write(String odf, JSONArray data){
        if (odf.equals("Control")) {
            String command = data.getString(0);
            JSONArray args = data.getJSONObject(1).getJSONArray("args");
            for (Command cmd: cmd_list) {
                if (command.equals(cmd.name)) {
                    cmd.run(args);
                    return;
                }
            }
            /* Reports exception to IoTtalk*/
        } else {
            for (DF df: df_list) {
                if (odf.equals(df.name)) {
                    ((ODF)df).write(data);
                }
            }
            /* Reports exception to IoTtalk*/
        }
    }
    /* Declaration of helper functions */
    private boolean is_selected(String df_name) {
        for (DF df: df_list) {
            if (df_name.equals(df.name)) {
                return df.selected;
            }
        }
        return false;
    }
    /* The main() function */
    public static void main(String[] args) {
        /* Initialization of default commands */
        add_command(
            new Command ("DF_LIST") {
                public void run(JSONArray args) {
                    /* Remember to fill df_list in DAI */
                }
            },
            new Command ("DF_STATUS") {
                public void run(JSONArray args) {
                    String flags = args.getString(0);
                    for (int i = 0; i < flags.length(); i++) {
                        if (flags.charAt(i) == '0') {
                            df_list.get(i).selected = false;
                        } else {
                            df_list.get(i).selected = true;
                        }
                    }
                }
            },
            new Command ("RESUME") {
                public void run(JSONArray args) {
                    suspended = false;
                }
            },
            new Command ("SUSPEND") {
                public void run(JSONArray args) {
                    suspended = true;
                }
            }
        );
        init_cmds();
        init_df_list();
        DAI.init(internal_ida_api);
        /* Performs the functionality of the IDA */
        PApplet.main(new String[] {"IDA"});
    }
    /* Customizable part */
    /* Declaration of ODF classes, generated by the DAC */
    static class Size extends ODF {
        public Size () {
            super("Size");
        }
        public static double y1;
        /* for each parameter yi of ODF1, there is
           a variable declaration generated by the DAC */
        public void write(JSONArray data) {
            /* parse data from packet, assign to every yi */
            y1 = data.getDouble(0);
        }
    }
    static class Angle extends ODF {
        public Angle () {
            super("Angle");
        }
        public static double y1;
        public void write(JSONArray data) {
            /* parse data from packet, assign to every yi */
            y1 = data.getDouble(0);
        }
    }
    static class Mouse extends IDF {
        public Mouse () {
            super("Mouse");
            name = this.getClass().getSimpleName();
        }
        public static String name;
        public static void read(double x, double y) {
            JSONArray data = new JSONArray();
            data.put(x);
            data.put(y);
            internal_ida_api.read(name, data);
        }
    }
    /* Initialization of command list and DF list, generated by the DAC */
    static void init_cmds () {
        add_command(
            new Command ("SAMPLE_COMMAND") {
                public void run(JSONArray args) {
                    /* Handles the command */
                }
            }
        );
    }
    static void init_df_list () {
        add_df(
            new Size(),
            new Angle(),
            new Mouse()
        );
    }
    /* IDA Application */
    final int LINE_WEIGHT = 1500;
    final int WIDTH = 1000;
    final int HEIGHT = WIDTH * 2 / 3;
    final float WINDOW_SIZE_SCALE = WIDTH / 900f;
    final float UNIT = 3f;                  // unit size
    final float A = (2.5f + 2 * UNIT);          // short side
    final float B = A / sin(radians(45));       // long side
    final int ALPHA_MAX = 1000;
    final int BRANCH_LENGTH = 18;
    final int MAX_LAYER = 10;
    final int BACKGROUND_GRAY_LEVEL = 255;
    final int FOREGROUND_GRAY_LEVEL = 0;
    double current_angle, current_size, current_layer;
    float b_x = B * cos(radians(60));
    float b_y = B * sin(radians(60));
    int delay = 150;
    float r = 1;                      // rotate parameter
    float count_r = 30f;              // rotate angle
    float rule;
    @Override
    public void setup() {
        smooth();
        size(WIDTH, HEIGHT);
        current_angle = 0f;
        current_size = 0f;
    }
    @Override
    public void draw(){
        if (suspended) {
            return;
        }
        draw(Size.y1, Angle.y1);
    }
    public void draw(double size, double angle){
        if (is_selected("Size")) {
            current_size += (size - current_size) / delay;
        }
        if (is_selected("Angle")) {
            current_angle += (angle - current_angle) / delay;
        }
        current_layer = current_size * MAX_LAYER;
        scale(2);
        smooth();
        background(BACKGROUND_GRAY_LEVEL);
        //frameRate(30);
        stroke(FOREGROUND_GRAY_LEVEL, LINE_WEIGHT);
        ///////////////////////////////////////////////////////////////////
        float ro = (float)current_angle * 120f;
        count_r = degrees(radians(ro));
        rule = 1.45f - (((float)current_size * HEIGHT) / (float)WIDTH * 100f) / 130;
        translate(width/4, height/3.65f);
        line(0,0,0,1000 * WINDOW_SIZE_SCALE);
        angle_branch(0);
    }
    void angle_branch (int level) {
        if (level >= MAX_LAYER || level > current_layer) {
            return;
        }
        float parameter = ((float)level / MAX_LAYER) / 2 + 1;
        float degree_a = degrees(acos(((BRANCH_LENGTH * parameter - A) / 2) / B));
        float target_x = BRANCH_LENGTH * cos(radians(120 - degree_a)) * parameter;
        float target_y = -BRANCH_LENGTH * sin(radians(120 - degree_a)) * parameter;
        float alpha_rate = (float)(current_layer - (int)current_layer);
        float alpha = (FOREGROUND_GRAY_LEVEL - BACKGROUND_GRAY_LEVEL) * alpha_rate + BACKGROUND_GRAY_LEVEL;
        float line_gray_level = (level + 1 > current_layer) ? alpha : FOREGROUND_GRAY_LEVEL;
        pushMatrix();
        rotate(radians(-count_r));
        stroke(line_gray_level, LINE_WEIGHT);
        line(0, 0, A * WINDOW_SIZE_SCALE, 0);
        line(0, 0, -b_x * WINDOW_SIZE_SCALE, -b_y * WINDOW_SIZE_SCALE);
        line(0, 0, target_x * WINDOW_SIZE_SCALE, target_y * WINDOW_SIZE_SCALE);
        translate(target_x * WINDOW_SIZE_SCALE, target_y * WINDOW_SIZE_SCALE);
        rotate(radians(2 * degree_a - 60));
        line(0, 0, A * WINDOW_SIZE_SCALE,0);
        line(0, 0, -b_x * WINDOW_SIZE_SCALE, b_y * WINDOW_SIZE_SCALE);
        angle_branch(level + 1); 
        popMatrix();
        pushMatrix();
        rotate(radians(count_r));
        stroke(line_gray_level, LINE_WEIGHT);
        line(0, 0, -A * WINDOW_SIZE_SCALE, 0);
        line(0, 0, b_x * WINDOW_SIZE_SCALE, -b_y * WINDOW_SIZE_SCALE);
        line(0, 0, -target_x * WINDOW_SIZE_SCALE, target_y * WINDOW_SIZE_SCALE);
        translate(-target_x * WINDOW_SIZE_SCALE, target_y * WINDOW_SIZE_SCALE);
        rotate(-radians(2*degree_a-60));
        line(0, 0, -A * WINDOW_SIZE_SCALE, 0);
        line(0, 0, b_x * WINDOW_SIZE_SCALE, b_y * WINDOW_SIZE_SCALE);
        angle_branch(level + 1);
        popMatrix();
    }
    @Override
    public void mouseMoved () {
        if (suspended || !is_selected("Mouse")) {
            return;
        }
        Mouse.read(mouseX, mouseY);
    }
}